---
title: "Custom statistics"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Custom statistics}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: references.bib
---

```{r setup, include=FALSE}
library(tidystats)

knitr::opts_chunk$set(echo = TRUE)
```

The normal `tidystats` workflow consists of running analyses 
(e.g., using `lm()`), saving the output into variables, and then using the 
`add_stats()` function to add them to a list. This works as long as `tidystats`
has built-in support for the analyses you ran. So what should you do when this 
is not the case?

The first thing would be to let me know that there's a function you would like 
`tidystats` to support. There are various ways to contact me. You can go to the 
Github [page](https://github.com/WillemSleegers/tidystats) and create an 
[issue](https://github.com/WillemSleegers/tidystats/issues). This is the 
preferred method because it is easy to paste code snippets and to ask follow-up 
questions. Alternatively, you can also contact me on 
[Twitter](https://twitter.com/willemsleegers).

But if you're in a rush, this does not help you. Nor is it always possible for 
me to add support for a specific analysis. This can happen when the statistic 
you want to report is not part of an analysis (for example, the result of 
`confint()` returns a standard matrix, which does not contain any information 
about it being a matrix containing confidence intervals).

For these reasons, it is sometimes nice if you can manually create your own 
list of statistics, so let's demonstrate how to do this.

To manually tidy statistics you have to do what `tidystats` normally does for 
you. That is, you need to provide the `add_stats()` function a list of 
statistics in a specific structure. I am currently working on a vignette that 
explains this structure. For now, you can use the examples below to figure out 
how to create a custom list of statistics and how to use it.

## Example 1

Say you want to calculate a Bayes Factor using the BIC approach ([Wagenmakers, 2007](https://doi.org/10.3758/BF03194105)). An example of this approach can be found [here](https://rstudio-pubs-static.s3.amazonaws.com/358672_09291d0b37ce43f08cf001cfd25c16c2.html); which I'll repeat down below.

```{r}
# Set seed for reproducibility
set.seed(14)

# Simulate some data
intercept_data <- data.frame(score = scale(rnorm(40), center = 0.72))

# Run two models and calculate the BIC
full_lm <- lm(score ~ 1, intercept_data)
null_lm <- lm(score ~ 0, intercept_data)

BF_BIC <- exp((BIC(null_lm) - BIC(full_lm)) / 2)
```

This produces a BIC of `r round(BF_BIC, 2)`. Now, how do you add this value to a tidystats list? If we try it the standard way, we'll see that it fails.

```{r, eval = FALSE}
# Load the tidystats package
library(tidystats)

# Create an empty list
results <- list()

# Add BIC to the list using add_stats()
results <- add_stats(results, BF_BIC)
```

This produces an error message that says:

> Error in UseMethod("tidy_stats") : no applicable method for 'tidy_stats' applied to an object of class "c('double', 'numeric')"

This is because `BF_BIC` is simply a number and not the output of a statistical test. Statistical tests often return an object with a specific class. `tidystats` checks the class of an object to figure out how to extract the statistics. But if the object is simply a number, tidystats doesn't know how to parse it. So let's do it manually.

```{r, eval = FALSE}
# Create an empty list
results <- list()

# Create a list containing the BIC
BIC <- list(
  method = "BIC",
  statistics = list(
    BIC = BF_BIC
  )
)

# Add the BIC to the list
results <- add_stats(results, BIC)
```

Now we don't get an error. `tidystats` sees that it is a list and assumes that you structured it correctly. That structure, in this case, consists of a list that contains an element called `statistics`, which is itself a list that contains an element called `BIC`, which has the BIC value we want to store.

You can save the `results` list using `write_stats()` and load the resulting JSON file into the Word add-in to reproducibly report the BIC value.

## Example 2

Let's look at a more complex example next. Say we want to calculate the confidence intervals for several parameters in a linear model, using the `confint()` function.

```{r, eval = FALSE}
# Run a linear model
fit <- lm(100 / mpg ~ disp, data = mtcars)

# Compute the confidence intervals
fit_CIs <- confint(fit)

# Create an empty list
results <- list()

# Add linear model and confidence intervals to the list
results <- results %>%
  add_stats(fit) %>%
  add_stats(fit_CIs)
```

Unfortunately, we again get an error. That's because `confint()` return a standard matrix, rather than an object specific to the `confint()` function. This means we need to manually tidy the confidence interval values.

```{r, eval = FALSE}
fit_CIs_list <- list(
  method = "Confidence intervals",
  terms = list(
    list(
      name = "(Intercept)",
      statistics = list(
        CI = list(
          CI_level = .95,
          CI_lower = fit_CIs[1, 1],
          CI_upper = fit_CIs[1, 2]
        )
      )
    ),
    list(
      name = "disp",
      statistics = list(
        CI = list(
          CI_level = .95,
          CI_lower = fit_CIs[2, 1],
          CI_upper = fit_CIs[2, 2]
        )
      )
    )
  )
)
```

This is a lot more complicated than in the previous example. That's because this particular case involves multiple terms that each contain statistics, which consist of confidence intervals, which consist of three elements: the level, the upper value, and the lower value. I am including this example to show you that it is possible to also tidy relatively complex structures, but ideally you have `tidystats` do this automatically for you.

Having done the custom tidying, it is now possible to add it to the list using `add_stats()`.

```{r, eval = FALSE}
# Create an empty list
results <- list()

# Add linear model and confidence intervals to the list
results <- results %>%
  add_stats(fit) %>%
  add_stats(fit_CIs_list)

# Save stats
write_stats(results, "results.json")
```

And, as before, you can load it up into the Word add-in to report the statistics.

## Summary

`tidystats` works by taking the output of statistical tests, extracting the statistics, and reorganizing them into a particular structure. This works if 1) `tidystats` has built-in support for the function and 2) if the function used to run the statistical test returns an object that `tidystats` can use to identify the test.

If you want to use `tidystats` on a function that is not supported yet, please contact me to let me know that I should add support for it.

Alternatively, you can manually create a list of statistics and supply it to the `add_stats()` function. Note that this list should have a specific structure.

The goal is to have `tidystats` support as many tests as possible, so that you rarely have to resort to this solution.
